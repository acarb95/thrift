/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

#include <stdio.h>
#include <glib-object.h>
#include <inttypes.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>

#include <thrift/c_glib/protocol/thrift_binary_protocol.h>
#include <thrift/c_glib/transport/thrift_buffered_udp_transport.h>
#include <thrift/c_glib/transport/thrift_udp_socket.h>
#include <thrift/c_glib/thrift.h>

#include "gen-c_glib/shared_memory_test.h"
#include "../lib/client_lib.h"
#include "../lib/config.h"
#include "../lib/utils.h"

gboolean srand_called = FALSE;

// UTILS --> copied to server b/c it's a pain to create a shared file (build issues)
void get_args_pointer(struct in6_memaddr *ptr, struct sockaddr_in6 *targetIP) {
  // Get random memory server
  struct in6_addr *ipv6Pointer = gen_ip6_target(0);

  // Put it's address in targetIP (why?)
  memcpy(&(targetIP->sin6_addr), ipv6Pointer, sizeof(*ipv6Pointer));

  // Allocate memory and receive the remote memory pointer
  struct in6_memaddr temp = allocate_rmem(targetIP);

  // Copy the remote memory pointer into the give struct pointer
  memcpy(ptr, &temp, sizeof(struct in6_memaddr));
}

void marshall_shmem_ptr(GByteArray **ptr, struct in6_memaddr *addr) {
  // Blank cmd section
  uint16_t cmd = 0u;

  // Copy wildcard (::)
  *ptr = g_byte_array_append(*ptr, (const gpointer) &(addr->wildcard), sizeof(uint32_t));
  // Copy subid (i.e., 103)
  *ptr = g_byte_array_append(*ptr, (const gpointer) &(addr->subid), sizeof(uint16_t));
  // Copy cmd (0)
  *ptr = g_byte_array_append(*ptr, (const gpointer) &cmd, sizeof(uint16_t));
  // Copy memory address (XXXX:XXXX)
  *ptr = g_byte_array_append(*ptr, (const gpointer) &(addr->paddr), sizeof(uint64_t));
}

void unmarshall_shmem_ptr(struct in6_memaddr *result_addr, GByteArray *result_ptr) {
  // Clear struct
  memset(result_addr, 0, sizeof(struct in6_memaddr));
  // Copy over received bytes
  memcpy(result_addr, result_ptr->data, sizeof(struct in6_memaddr));
}

void populate_array(uint8_t **array, int array_len, uint8_t start_num, gboolean random) {
  uint8_t num = start_num;
  if (!srand_called && random) {
    srand(time(NULL));
    srand_called = TRUE;
  }

  for (int i = 0; i < array_len; i++) {
    (*array)[i] = num;
    if (!random)
      num++;
    else
      num = (uint8_t) rand();
  }
}

void usage(char* prog_name, char* message) {
  printf("ERROR: %s", message);
  printf("USAGE: %s -c <config>\n", prog_name);
  printf("\t-c is a required argument");
  printf("\t<config> is the bluebridge config (generated by mininet)");
}

// TESTS
void test_server_functionality(SharedMemoryTestIf *client) {
  GError *error = NULL;
  CallException *exception = NULL;

  // TEST: ping
  printf("Testing ping...\t\t\t");
  if (shared_memory_test_if_ping (client, &error)) {
    printf("SUCCESS\n");
  } else {
    printf("FAILED\n");
    printf("\tERROR: %s\n", error->message);
    g_clear_error (&error);
  }

  // TEST: allocate_mem
  printf("Testing allocate_mem...\t\t");
  GByteArray* res = NULL;
  if (shared_memory_test_if_allocate_mem(client, &res, 4096, &exception, &error)) {
    printf("SUCCESS\n");
  } else {
    printf("FAILED\n");
    printf("\tERROR: %s\n", error->message);
    g_clear_error (&error);
  }

  // TEST: write_mem
  printf("Testing write_mem...\t\t");
  // Clear payload
  char *payload = malloc(4096);
  snprintf(payload, 50, "HELLO WORLD! How are you?");
  if (shared_memory_test_if_write_mem(client, res, payload, &exception, &error)) {
    printf ("SUCCESS\n");
  } else {
    printf("FAILED\n");
    printf("\tERROR: %s\n", error->message);
    g_clear_error (&error);
  }

  // TEST: read_mem
  printf("Testing read_mem...\t\t");
  if (shared_memory_test_if_read_mem(client, res, &exception, &error)) {
    printf ("SUCCESS\n");
  } else {
    printf("FAILED\n");
    printf("\tERROR: %s\n", error->message);
    g_clear_error (&error);
  }

  // TEST: free_mem
  printf("Testing free_mem...\t\t");
  if (shared_memory_test_if_free_mem(client, res, &exception, &error)) {
    printf ("SUCCESS\n");
  } else {
    printf("FAILED\n");
    printf("\tERROR: %s\n", error->message);
    g_clear_error (&error);
  }

  // Clean up memory
  free(payload);
}

void increment_array(SharedMemoryTestIf *client, struct sockaddr_in6 *targetIP) {
  GError *error = NULL;                       // Error (in transport, socket, etc.)
  CallException *exception = NULL;            // Exception (thrown by server)
  struct in6_memaddr args_addr;               // Shared memory address of the argument pointer
  GByteArray* args_ptr = g_byte_array_new();  // Argument pointer
  GByteArray* result_ptr = NULL;              // Result pointer
  uint8_t *arr;                               // Array to be sent (must be uint8_t to match char size)
  int arr_len = 10;                           // Size of array to be sent
  uint8_t incr_val = 1;                       // Value to increment each value in the array by

  printf("Testing increment_array...\t");

  // Get a shared memory pointer for argument array
  get_args_pointer(&args_addr, targetIP);

  // Create argument array
  arr = malloc(arr_len*sizeof(uint8_t));
  populate_array(&arr, arr_len, 0, FALSE);

  // Write array to shared memory
  write_rmem(targetIP, (char*) arr, &args_addr);

  // Marshall shared pointer address
  marshall_shmem_ptr(&args_ptr, &args_addr);

  // CALL RPC
  shared_memory_test_if_increment_array(client, &result_ptr, args_ptr, incr_val, arr_len, &exception, &error);
  if (error) {
    printf ("ERROR: %s\n", error->message);
    g_clear_error (&error);
  } else if (exception) {
    gint32 err_code;
    gchar *message;

    g_object_get(exception, "message", &message,
                            "err_code", &err_code,
                            NULL);

    // TODO: make a print macro that changes the message based on the error_code
    printf("EXCEPTION %d: %s\n", err_code, message);
  }

  // Unmarshall shared pointer address
  struct in6_memaddr result_addr;
  unmarshall_shmem_ptr(&result_addr, result_ptr);

  // Create result array to read into
  char* result_arr = malloc(arr_len);

  // Read in result array
  get_rmem(result_arr, arr_len, targetIP, &result_addr);

  // Make sure the server returned the correct result
  for (int i = 0; i < arr_len; i++) {
    if ((uint8_t) result_arr[i] != arr[i] + incr_val) {
      printf("FAILED: result (%d) does not match expected result (%d) at index (%d)\n", (uint8_t) result_arr[i], arr[i] + incr_val, i);
    }
  }

  // Free malloc'd and GByteArray memory
  free(result_arr);
  free(arr);
  g_byte_array_free(args_ptr, TRUE);  // We allocated this, so we free it
  g_byte_array_unref(result_ptr);     // We only received this, so we dereference it

  printf("SUCCESS\n");
}

void add_arrays(SharedMemoryTestIf *client, struct sockaddr_in6 *targetIP) {
  GError *error = NULL;                       // Error (in transport, socket, etc.)
  CallException *exception = NULL;            // Exception (thrown by server)
  struct in6_memaddr arg1_addr;               // Shared memory address of the argument pointer
  struct in6_memaddr arg2_addr;               // Shared memory address of the argument pointer
  GByteArray* arg1_ptr = g_byte_array_new();  // Argument pointer
  GByteArray* arg2_ptr = g_byte_array_new();  // Argument pointer
  GByteArray* result_ptr = NULL;              // Result pointer
  struct in6_memaddr result_addr;             // Shared memory address of result
  uint8_t *arr1;                              // Array 1 to be added
  uint8_t *arr2;                              // Array 2 to be added
  int arrays_len = 10;                        // Size of array to be sent

  printf("Testing add_arrays...\t\t");

  // Get pointers for arrays
  get_args_pointer(&arg1_addr, targetIP);
  get_args_pointer(&arg2_addr, targetIP);

  // Populate arrays
  arr1 = malloc(arrays_len*sizeof(uint8_t));
  arr2 = malloc(arrays_len*sizeof(uint8_t));
  populate_array(&arr1, arrays_len, 3, TRUE);
  populate_array(&arr2, arrays_len, 5, TRUE);

  // Write arrays to shared memory
  write_rmem(targetIP, (char*) arr1, &arg1_addr);
  write_rmem(targetIP, (char*) arr2, &arg2_addr);

  // Marshall shared pointer addresses
  marshall_shmem_ptr(&arg1_ptr, &arg1_addr);
  marshall_shmem_ptr(&arg2_ptr, &arg2_addr);

  // CALL RPC
  shared_memory_test_if_add_arrays(client, &result_ptr, arg1_ptr, arg2_ptr, arrays_len, &exception, &error);
  if (error) {
    printf ("ERROR: %s\n", error->message);
    g_clear_error (&error);
  } else if (exception) {
    gint32 err_code;
    gchar *message;

    g_object_get(exception, "message", &message,
                            "err_code", &err_code,
                            NULL);

    // TODO: make a print macro that changes the message based on the error_code
    printf("EXCEPTION %d: %s\n", err_code, message);
  } else {
    // Unmarshall shared pointer address
    unmarshall_shmem_ptr(&result_addr, result_ptr);

    // Create result array to read into
    char* result_arr = malloc(arrays_len);

    // Read in result array
    get_rmem(result_arr, arrays_len, targetIP, &result_addr);

    // Make sure the server returned the correct result
    uint8_t expected = 0;
    for (int i = 0; i < arrays_len; i++) {
      expected = arr1[i] + arr2[i];
      if ((uint8_t) result_arr[i] != (uint8_t) (arr1[i] + arr2[i])) {
        printf("FAILED: result (%d) does not match expected result (%d) at index (%d)\n", (uint8_t) result_arr[i], expected, i);
        goto cleanupres;
      }
    }

    printf("SUCCESS\n");

cleanupres:
    free(result_arr);
  }

  // Free malloc'd and GByteArray memory
  free(arr1);
  free(arr2);
  g_byte_array_free(arg1_ptr, TRUE);  // We allocated this, so we free it
  g_byte_array_free(arg2_ptr, TRUE);  // We allocated this, so we free it
  g_byte_array_unref(result_ptr);     // We only received this, so we dereference it
}

void mat_multiply(SharedMemoryTestIf *client, struct sockaddr_in6 *targetIP) {
  // GError *error = NULL;                       // Error (in transport, socket, etc.)
  // CallException *exception = NULL;            // Exception (thrown by server)
  // struct in6_memaddr args_addr;               // Shared memory address of the argument pointer
  // GByteArray* args_ptr = g_byte_array_new();  // Argument pointer
  // GByteArray* result_ptr = NULL;              // Result pointer

  THRIFT_UNUSED_VAR(client);
  THRIFT_UNUSED_VAR(targetIP);
}

void word_count(SharedMemoryTestIf *client, struct sockaddr_in6 *targetIP) {
  // GError *error = NULL;                       // Error (in transport, socket, etc.)
  // CallException *exception = NULL;            // Exception (thrown by server)
  // struct in6_memaddr args_addr;               // Shared memory address of the argument pointer
  // GByteArray* args_ptr = g_byte_array_new();  // Argument pointer
  // GByteArray* result_ptr = NULL;              // Result pointer
    THRIFT_UNUSED_VAR(client);
  THRIFT_UNUSED_VAR(targetIP);
}

void sort_array(SharedMemoryTestIf *client, struct sockaddr_in6 *targetIP) {
  // GError *error = NULL;                       // Error (in transport, socket, etc.)
  // CallException *exception = NULL;            // Exception (thrown by server)
  // struct in6_memaddr args_addr;               // Shared memory address of the argument pointer
  // GByteArray* args_ptr = g_byte_array_new();  // Argument pointer
  // GByteArray* result_ptr = NULL;              // Result pointer
    THRIFT_UNUSED_VAR(client);
  THRIFT_UNUSED_VAR(targetIP);
}


void test_shared_pointer_rpc(SharedMemoryTestIf *client, struct sockaddr_in6 *targetIP) {
  increment_array(client, targetIP);
  add_arrays(client, targetIP);
  mat_multiply(client, targetIP);
  word_count(client, targetIP);
  sort_array(client, targetIP);
}

int main (int argc, char *argv[]) {
  ThriftUDPSocket *socket;
  ThriftTransport *transport;
  ThriftProtocol *protocol;
  SharedMemoryTestIf *client;

  GError *error = NULL;

  int c; 
  struct config myConf;
  struct sockaddr_in6 *targetIP;

  if (argc < 3) {
    usage(argv[0], "Not enough arguments");
    return -1;
  }

  while ((c = getopt (argc, argv, "c:")) != -1) { 
  switch (c) 
    { 
    case 'c':
      myConf = set_bb_config(optarg, 0);
      break;
    case '?':
      usage(argv[0], "");
      return 0; 
    default: ; // b/c cannot create variable after label
      char *message = malloc(180);
      snprintf (message, 180, "Unknown option `-%c'.\n", optopt);
      usage(argv[0], message);
      free(message);
      return -1;
    } 
  }

  targetIP = init_sockets(&myConf, 0);
  set_host_list(myConf.hosts, myConf.num_hosts);

#if (!GLIB_CHECK_VERSION (2, 36, 0))
  g_type_init ();
#endif

  socket    = g_object_new (THRIFT_TYPE_UDP_SOCKET,
                            "hostname",  "0:0:102::",
                            "port",      9090,
                            NULL);
  transport = g_object_new (THRIFT_TYPE_BUFFERED_UDP_TRANSPORT,
                            "transport", socket,
                            NULL);
  protocol  = g_object_new (THRIFT_TYPE_BINARY_PROTOCOL,
                            "transport", transport,
                            NULL);

  thrift_transport_open (transport, &error);
  if (error) {
    printf ("ERROR: %s\n", error->message);
    g_clear_error (&error);
    return 1;
  }

  client = g_object_new (TYPE_SHARED_MEMORY_TEST_CLIENT,
                         "input_protocol",  protocol,
                         "output_protocol", protocol,
                         NULL);
  

  printf("\n\n###### Server functionality tests ######\n");
  test_server_functionality(client);

  printf("\n####### Shared pointer RPC tests #######\n");
  test_shared_pointer_rpc(client, targetIP);


  printf("\n\nCleaning up...\n");
  thrift_transport_close (transport, NULL);

  g_object_unref (client);
  g_object_unref (protocol);
  g_object_unref (transport);
  g_object_unref (socket);

  return 0;
}
