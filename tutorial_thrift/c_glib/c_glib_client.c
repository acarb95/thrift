/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

#include <stdio.h>
#include <glib-object.h>
#include <inttypes.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>

#include <thrift/c_glib/protocol/thrift_binary_protocol.h>
#include <thrift/c_glib/transport/thrift_buffered_transport.h>
#include <thrift/c_glib/transport/thrift_socket.h>
#include <thrift/c_glib/thrift.h>

#include "gen-c_glib/remote_memory_test.h"
#include "gen-c_glib/simple_array_computation.h"
#include "../lib/client_lib.h"
#include "../lib/config.h"
#include "../lib/utils.h"

gboolean srand_called = FALSE;

// UTILS --> copied to server b/c it's a pain to create a shared file (build issues)
void get_args_pointer(struct in6_memaddr *ptr, struct sockaddr_in6 *targetIP) {
  // Get random memory server
  struct in6_addr *ipv6Pointer = gen_rdm_ip6_target();

  // Put it's address in targetIP (why?)
  memcpy(&(targetIP->sin6_addr), ipv6Pointer, sizeof(*ipv6Pointer));

  // Allocate memory and receive the remote memory pointer
  struct in6_memaddr temp = allocate_rmem(targetIP);

  // Copy the remote memory pointer into the give struct pointer
  memcpy(ptr, &temp, sizeof(struct in6_memaddr));
}

void marshall_shmem_ptr(GByteArray **ptr, struct in6_memaddr *addr) {
  // Blank cmd section
  uint16_t cmd = 0u;

  // Copy wildcard (::)
  *ptr = g_byte_array_append(*ptr, (const gpointer) &(addr->wildcard), sizeof(uint32_t));
  // Copy subid (i.e., 103)
  *ptr = g_byte_array_append(*ptr, (const gpointer) &(addr->subid), sizeof(uint16_t));
  // Copy cmd (0)
  *ptr = g_byte_array_append(*ptr, (const gpointer) &cmd, sizeof(uint16_t));
  // Copy memory address (XXXX:XXXX)
  *ptr = g_byte_array_append(*ptr, (const gpointer) &(addr->paddr), sizeof(uint64_t));
}

void unmarshall_shmem_ptr(struct in6_memaddr *result_addr, GByteArray *result_ptr) {
  // Clear struct
  memset(result_addr, 0, sizeof(struct in6_memaddr));
  // Copy over received bytes
  memcpy(result_addr, result_ptr->data, sizeof(struct in6_memaddr));
}

void populate_array(uint8_t **array, int array_len, uint8_t start_num, gboolean random) {
  uint8_t num = start_num;
  if (!srand_called && random) {
    srand(time(NULL));
    srand_called = TRUE;
  }

  for (int i = 0; i < array_len; i++) {
    (*array)[i] = num;
    if (!random) {
      num++;
      num = num % UINT8_MAX;
    } else {
      num = ((uint8_t) rand()) % UINT8_MAX;
    }
  }
}

void usage(char* prog_name, char* message) {
  if (strlen(message) > 0)
    printf("ERROR: %s\n", message);
  printf("USAGE: %s -c <config> -i <num_iterations>\n", prog_name);
  printf("Where");
  printf("\t-c <config> is required and the bluebridge config (generated by mininet)\n");
  printf("\t-i <num_iterations is required and the number of iterations to run the performance test.\n");
}

// TESTS
uint64_t test_ping(RemoteMemoryTestIf *client, GError *error, gboolean print) {
  if(print)
    printf("Testing ping...\t\t\t");
  
  uint64_t ping_start = getns();
  gboolean success = remote_memory_test_if_ping (client, &error);
  uint64_t ping_time = getns() - ping_start;

  if (print){
    if (success) {
      printf("SUCCESS\n");
    } else {
      printf("FAILED\n");
      printf("\tERROR: %s\n", error->message);
      g_clear_error (&error);
    }
  }
  return ping_time;
}

uint64_t test_server_alloc(RemoteMemoryTestIf *client, GByteArray **res, CallException *exception, GError *error, gboolean print) {
  if (print)
    printf("Testing allocate_mem...\t\t");
  
  uint64_t alloc_start = getns();
  gboolean success = remote_memory_test_if_allocate_mem(client, res, 4096, &exception, &error);
  uint64_t alloc_time = getns() - alloc_start;

  if (print) {
    if (success) {
      printf("SUCCESS\n");
    } else {
      // TODO add exception case
      printf("FAILED\n");
      printf("\tERROR: %s\n", error->message);
      g_clear_error (&error);
    }
  }

  return alloc_time;
}

uint64_t test_server_write(RemoteMemoryTestIf *client, GByteArray *res, CallException *exception, GError *error, gboolean print) {
  if (print)
    printf("Testing write_mem...\t\t");

  // Clear payload
  char *payload = malloc(4096);
  snprintf(payload, 50, "HELLO WORLD! How are you?");

  uint64_t write_start = getns();
  gboolean success = remote_memory_test_if_write_mem(client, res, payload, &exception, &error);
  uint64_t write_time = getns() - write_start;

  if (print) {
    if (success) {
      printf ("SUCCESS\n");
    } else {
      // TODO: add exception case
      printf("FAILED\n");
      printf("\tERROR: %s\n", error->message);
      g_clear_error (&error);
    }
  }

  free(payload);
  return write_time;
}

uint64_t test_server_read(RemoteMemoryTestIf *client, GByteArray *res, CallException *exception, GError *error, gboolean print) {
  if (print)
    printf("Testing read_mem...\t\t");
  
  uint64_t read_start = getns();
  gboolean success = remote_memory_test_if_read_mem(client, res, &exception, &error);
  uint64_t read_time = getns() - read_start;

  if (print) {
    if (success) {
      printf ("SUCCESS\n");
    } else {
      printf("FAILED\n");
      printf("\tERROR: %s\n", error->message);
      g_clear_error (&error);
    }
  }

  return read_time;
}

uint64_t test_server_free(RemoteMemoryTestIf *client, GByteArray *res, CallException *exception, GError *error, gboolean print) {
  if (print)
    printf("Testing free_mem...\t\t");
  
  uint64_t free_start = getns();
  gboolean success = remote_memory_test_if_free_mem(client, res, &exception, &error);
  uint64_t free_time = getns() - free_start;

  if (print) {
    if (success) {
      printf ("SUCCESS\n");
    } else {
      printf("FAILED\n");
      printf("\tERROR: %s\n", error->message);
      g_clear_error (&error);
    }
  }

  return free_time;
}

void test_server_functionality(RemoteMemoryTestIf *client) {
  GError *error = NULL;
  CallException *exception = NULL;
  GByteArray* res = NULL;

  test_ping(client, error, TRUE);

  test_server_alloc(client, &res, exception, error, TRUE);

  test_server_write(client, res, exception, error, TRUE);

  test_server_read(client, res, exception, error, TRUE);

  test_server_free(client, res, exception, error, TRUE);
}

uint64_t test_increment_array(SimpleArrayComputationIf *client, int size, gboolean print) {
  GError *error = NULL;                       // Error (in transport, socket, etc.)
  CallException *exception = NULL;            // Exception (thrown by server)
  GArray* result_array = g_array_new(FALSE, FALSE, sizeof(uint8_t));              // Result pointer
  int arr_len = size;                           // Size of array to be sent
  uint8_t incr_val = 1;                       // Value to increment each value in the array by
  GArray* arr = g_array_new(TRUE, TRUE, sizeof(uint8_t));                               // Array to be sent (must be uint8_t to match char size)
  uint8_t* temp = NULL;

  if (print)
    printf("Testing increment_array...\t");

  uint64_t start = getns();

  // Create argument array
  temp = malloc(arr_len*sizeof(uint8_t));
  populate_array(&temp, arr_len, 0, FALSE);

  g_array_append_vals(arr, temp, arr_len);

  // CALL RPC
  simple_array_computation_if_increment_array(client, &result_array, arr, incr_val, arr_len, &exception, &error);
  if (print) {
    if (error) {
      printf ("ERROR: %s\n", error->message);
      g_clear_error (&error);
    } else if (exception) {
      gint32 err_code;
      gchar *message;

      g_object_get(exception, "message", &message,
                              "err_code", &err_code,
                              NULL);

      // TODO: make a print macro that changes the message based on the error_code
      printf("EXCEPTION %d: %s\n", err_code, message);
    }
  }

  if (print) {
    // Make sure the server returned the correct result
    for (int i = 0; i < arr_len; i++) {
      if (g_array_index(result_array, uint8_t, i) != g_array_index(arr, uint8_t, i) + incr_val) {
        printf("FAILED: result (%d) does not match expected result (%d) at index (%d)\n", g_array_index(result_array, uint8_t, i), g_array_index(arr, uint8_t, i) + incr_val, i);
      }
    }
  }

  // Free malloc'd and GByteArray memory
  free(temp);

  uint64_t total = getns() - start;

  if (print)
    printf("SUCCESS\n");

  return total;
}

uint64_t test_add_arrays(SimpleArrayComputationIf *client, int size, gboolean print) {
  GError *error = NULL;                       // Error (in transport, socket, etc.)
  CallException *exception = NULL;            // Exception (thrown by server)
  int arrays_len = size;                        // Size of array to be sent
  GArray* array1 = g_array_sized_new(TRUE, TRUE, sizeof(uint8_t), arrays_len);  // Argument pointer
  GArray* array2 = g_array_sized_new(TRUE, TRUE, sizeof(uint8_t), arrays_len);  // Argument pointer
  GArray* result_arr = g_array_new(TRUE, TRUE, sizeof(uint8_t));;              // Result pointer
  uint8_t *temp1;                              // Array 1 to be added
  uint8_t *temp2;                              // Array 2 to be added

  if (print)
    printf("Testing add_arrays...\t\t");

  uint64_t start = getns();

  // Populate arrays
  temp1 = malloc(arrays_len*sizeof(uint8_t));
  temp2 = malloc(arrays_len*sizeof(uint8_t));
  populate_array(&temp1, arrays_len, 3, TRUE);
  populate_array(&temp2, arrays_len, 5, TRUE);

  g_array_append_vals(array1, temp1, arrays_len);
  g_array_append_vals(array2, temp2, arrays_len);

  // CALL RPC
  simple_array_computation_if_add_arrays(client, &result_arr, array1, array2, arrays_len, &exception, &error);
  if (error) {
    printf ("ERROR: %s\n", error->message);
    g_clear_error (&error);
  } else if (exception) {
    gint32 err_code;
    gchar *message;

    g_object_get(exception, "message", &message,
                            "err_code", &err_code,
                            NULL);

    // TODO: make a print macro that changes the message based on the error_code
    printf("EXCEPTION %d: %s\n", err_code, message);
  } else {
    if (print) {
      // Make sure the server returned the correct result
      uint8_t expected = 0;
      for (int i = 0; i < arrays_len; i++) {
        expected = temp1[i] + temp2[i];
        if ((uint8_t) result_arr->data[i] != (uint8_t) (temp1[i] + temp2[i])) {
          printf("FAILED: result (%d) does not match expected result (%d) at index (%d)\n", (uint8_t) result_arr->data[i], expected, i);
        }
      }

      printf("SUCCESS\n");
    }
  }

  // Free malloc'd and GByteArray memory
  free(temp1);
  free(temp2);

  return getns() - start;
}

gint8 dot_prod_helper(GArray* x, const GArray* y, int m) {
  gint8 res = 0;

  for (int i = 0; i < m; i++) {
    res += g_array_index(x, gint8, i) + g_array_index(y, gint8, i);
  }

  return res;
}

void mat_multiply(SimpleArrayComputationIf *client, gboolean print) {
  GError *error = NULL;                       // Error (in transport, socket, etc.)
  CallException *exception = NULL;            // Exception (thrown by server)
  int32_t length = 10;
  tuple* dimension = g_object_new(TYPE_TUPLE,
                                 "n", 15,
                                 "m", length,
                                 NULL);
  GArray* vector = g_array_sized_new(FALSE, FALSE, sizeof(uint8_t), length);  // Argument pointer
  GPtrArray* matrix = g_ptr_array_sized_new(dimension->n);
  GArray* result_vector = g_array_new(FALSE, FALSE, sizeof(uint8_t));              // Result pointer

  if(print) {
    printf("Testing matrix multiply...");
  }

  // Populate vector
  uint8_t *temp = malloc(length*sizeof(uint8_t));
  populate_array(&temp, length, 1, FALSE);
  g_array_append_vals(vector, temp, length);

  // Populate Matrix
  for (int i = 0; i < dimension->n; i++) {
    uint8_t *vec = malloc(length*sizeof(uint8_t));
    populate_array(&vec, length, i, FALSE);
    GArray* temp_row = g_array_sized_new(FALSE, FALSE, sizeof(uint8_t), length);
    g_array_append_vals(temp_row, vec, length);
    g_ptr_array_add(matrix, temp_row);
    g_array_ref(temp_row);
  }

  // for (int i = 0; i < dimension->n; i++) {
  //   GArray* row = g_ptr_array_index(matrix, i);
  //   for (int j = 0; j < dimension->m; j++) {
  //     printf("%d,", g_array_index(row, uint8_t, j));
  //   }
  //   printf("\n");
  // }

  simple_array_computation_if_mat_multiply (client, &result_vector, vector, matrix, length, dimension, &exception, &error);
  if (error) {
    printf ("ERROR: %s\n", error->message);
    g_clear_error (&error);
  } else if (exception) {
    gint32 err_code;
    gchar *message;

    g_object_get(exception, "message", &message,
                            "err_code", &err_code,
                            NULL);

    // TODO: make a print macro that changes the message based on the error_code
    printf("EXCEPTION %d: %s\n", err_code, message);
  } else {
    if (print) {
      // Make sure the server returned the correct result
      for (int i = 0; i < dimension->n; i++) {
        gint8 expected = dot_prod_helper(g_ptr_array_index(matrix, i), vector, dimension->m);
        gint8 got = g_array_index(result_vector, gint8, i);
        if (got != expected) {
          printf("FAILED: result (%d) does not match expected result (%d) at index (%d)\n", got, expected, i);
        }
      }

      printf("\tSUCCESS\n");
    }
  }

}

void word_count(SimpleArrayComputationIf *client) {
  // GError *error = NULL;                       // Error (in transport, socket, etc.)
  // CallException *exception = NULL;            // Exception (thrown by server)
  // GArray* args_ptr = g_array_sized_new(FALSE, FALSE, sizeof(char), length);  // Argument pointer
  // gint32* count_res = 0;              // Result pointer
  THRIFT_UNUSED_VAR(client);
}

void sort_array(SimpleArrayComputationIf *client) {
  // GError *error = NULL;                       // Error (in transport, socket, etc.)
  // CallException *exception = NULL;            // Exception (thrown by server)
  // GArray* args_ptr = g_array_sized_new(FALSE, FALSE, sizeof(uint8_t), length);  // Argument pointer
  // GArray* result_ptr = g_array_new(FALSE, FALSE, sizeof(uint8_t));              // Result pointer
  THRIFT_UNUSED_VAR(client);
}

uint64_t no_op_rpc(SimpleArrayComputationIf *client, int size) {
  GError *error = NULL;                       // Error (in transport, socket, etc.)
  int arr_len = size;                           // Size of array to be sent
  GArray* arr = g_array_sized_new(TRUE, TRUE, sizeof(uint8_t), arr_len);  // Argument pointer
  GArray* result_array = g_array_new(FALSE, FALSE, sizeof(uint8_t));              // Result pointer
  uint8_t *temp;                               // Array to be sent (must be uint8_t to match char size)

  THRIFT_UNUSED_VAR(client);

  uint64_t start = getns();

  // Create argument array
  temp = malloc(arr_len*sizeof(uint8_t));
  populate_array(&temp, arr_len, 0, FALSE);

  g_array_append_vals(arr, temp, arr_len);

  // CALL RPC
  simple_array_computation_if_no_op(client, &result_array, arr, arr_len, &error);
  if (error) {
    printf ("ERROR: %s\n", error->message);
    g_clear_error (&error);
  }
  
  return getns() - start;
}

void test_shared_pointer_rpc(SimpleArrayComputationIf *client) {
  test_increment_array(client, 4095, TRUE);
  test_add_arrays(client, 4095, TRUE);
  // mat_multiply(client, TRUE);
  // word_count(client, TRUE);
  // sort_array(client, TRUE);
}

void microbenchmark_perf(RemoteMemoryTestIf *client, int iterations) {
  GError *error = NULL;
  CallException *exception = NULL;

  // Call perf test for ping
  uint64_t *ping_times = malloc(iterations*sizeof(uint64_t));
  uint64_t ping_total = 0;
  uint64_t *alloc_times = malloc(iterations*sizeof(uint64_t));
  uint64_t alloc_total = 0;
  uint64_t *write_times = malloc(iterations*sizeof(uint64_t));
  uint64_t write_total = 0;
  uint64_t *read_times = malloc(iterations*sizeof(uint64_t));
  uint64_t read_total = 0;
  uint64_t *free_times = malloc(iterations*sizeof(uint64_t));
  uint64_t free_total = 0;

  for (int i = 0; i < iterations; i++) {
    GByteArray* res = NULL;

    ping_times[i] = test_ping(client, error, FALSE);
    ping_total += ping_times[i];

    alloc_times[i] = test_server_alloc(client, &res, exception, error, FALSE);
    alloc_total += alloc_times[i];

    write_times[i] = test_server_write(client, res, exception, error, FALSE);
    write_total += write_times[i];

    read_times[i] = test_server_read(client, res, exception, error, FALSE);
    read_total += read_times[i];

    free_times[i] = test_server_free(client, res, exception, error, FALSE);
    free_total += free_times[i];
  }

  printf("Average %s latency: "KRED"%lu us\n"RESET, "ping", ping_total / (iterations*1000));
  printf("Average %s latency: "KRED"%lu us\n"RESET, "alloc", alloc_total / (iterations*1000));
  printf("Average %s latency: "KRED"%lu us\n"RESET, "write", write_total / (iterations*1000));
  printf("Average %s latency: "KRED"%lu us\n"RESET, "read", read_total / (iterations*1000));
  printf("Average %s latency: "KRED"%lu us\n"RESET, "free", free_total / (iterations*1000));

  free(ping_times);
  free(alloc_times);
  free(write_times);
  free(read_times);
  free(free_times);
}

void no_op_perf(SimpleArrayComputationIf *client, int iterations) {
  uint64_t *no_op_rpc_times = malloc(iterations*sizeof(uint64_t));
  uint64_t no_op_rpc_total = 0;

  for (int i = 0; i < iterations; i++) {
    no_op_rpc_times[i] = no_op_rpc(client, 4095);
    no_op_rpc_total += no_op_rpc_times[i];
  }

  printf("Average %s latency: "KRED"%lu us\n"RESET, "no_op_rpcs", no_op_rpc_total / (iterations*1000));

  free(no_op_rpc_times);
}

void increment_array_perf(SimpleArrayComputationIf *client, int iterations, int max_size, int incr, FILE* outfile) {
  // uint64_t *increment_array_times = malloc(iterations*sizeof(uint64_t));
  uint64_t increment_array_total = 0;

  fprintf(outfile, "size,us latency\n");
  for (int s = 0; s < max_size; s+=incr) {
    increment_array_total = 0;
    for (int i = 0; i < iterations; i++) {
      increment_array_total = test_increment_array(client, s, FALSE);
      // increment_array_total += increment_array_times[i];
    }
    // printf("Average %s latency (%d): "KRED"%lu us\n"RESET, "increment_array", s, increment_array_total / (iterations*1000));
    fprintf(outfile, "%d,%lu\n", s, increment_array_total / (iterations*1000));
  }

  // free(increment_array_times);
}

void add_arrays_perf(SimpleArrayComputationIf *client, int iterations, int max_size, int incr, FILE* outfile) {
  // uint64_t *add_arrays_times = malloc(iterations*sizeof(uint64_t));
  uint64_t add_arrays_total = 0;

  fprintf(outfile, "size,us latency\n");
  for (int s = 0; s < max_size; s+=incr) {
    add_arrays_total = 0;
    for (int i = 0; i < iterations; i++) {
      add_arrays_total = test_add_arrays(client, s, FALSE);
      // add_arrays_total += add_arrays_times[i];
    }
    // printf("Average %s latency (%d): "KRED"%lu us\n"RESET, "add_arrays", s, add_arrays_total / (iterations*1000));
    fprintf(outfile, "%d,%lu\n", s, add_arrays_total / (iterations*1000));
  }


  // free(add_arrays_times);
}

void test_shared_pointer_perf(RemoteMemoryTestIf *remmem_client, SimpleArrayComputationIf *arrcomp_client, int iterations) {
  FILE* incrarr_outfile = fopen("./incr_array_results.csv", "w");
  FILE* addarr_outfile = fopen("./add_array_results.csv", "w");

  microbenchmark_perf(remmem_client, iterations);

  // TODO: debug, only the first one of these will work consistently, then the server seg faults
  // on a write_rmem. We might be running out of memory somewhere?

  // Call perf test for no-op RPC
  no_op_perf(arrcomp_client, iterations);

  // Call perf test for increment array rpc
  increment_array_perf(arrcomp_client, iterations, 4095, 10, incrarr_outfile);

  // Call perf test for add arrays
  add_arrays_perf(arrcomp_client, iterations, 4094, 10, addarr_outfile);

  fclose(incrarr_outfile);
  fclose(addarr_outfile);
}

int main (int argc, char *argv[]) {
  ThriftSocket *remmem_socket;
  ThriftTransport *remmem_transport;
  ThriftProtocol *remmem_protocol;
  RemoteMemoryTestIf *remmem_client;

  ThriftSocket *arrcomp_socket;
  ThriftTransport *arrcomp_transport;
  ThriftProtocol *arrcomp_protocol;
  SimpleArrayComputationIf *arrcomp_client;

  GError *error = NULL;

  int c; 
  struct config myConf;
  struct sockaddr_in6 *targetIP;
  int iterations = 0;

  if (argc < 5) {
    usage(argv[0], "Not enough arguments");
    return -1;
  }

  while ((c = getopt (argc, argv, "c:i:")) != -1) { 
  switch (c) 
    { 
    case 'c':
      myConf = set_bb_config(optarg, 0);
      break;
    case 'i':
      iterations = atoi(optarg);
      break;
    case '?':
      usage(argv[0], "");
      return 0; 
    default: ; // b/c cannot create variable after label
      char *message = malloc(180);
      snprintf (message, 180, "Unknown option `-%c'.\n", optopt);
      usage(argv[0], message);
      free(message);
      return -1;
    } 
  }

  targetIP = init_sockets(&myConf, 0);
  set_host_list(myConf.hosts, myConf.num_hosts);

#if (!GLIB_CHECK_VERSION (2, 36, 0))
  g_type_init ();
#endif

  remmem_socket    = g_object_new (THRIFT_TYPE_SOCKET,
                            "hostname",  "0:0:102::",
                            "port",      9080,
                            NULL);
  remmem_transport = g_object_new (THRIFT_TYPE_BUFFERED_TRANSPORT,
                            "transport", remmem_socket,
                            NULL);
  remmem_protocol  = g_object_new (THRIFT_TYPE_BINARY_PROTOCOL,
                            "transport", remmem_transport,
                            NULL);

  thrift_transport_open (remmem_transport, &error);
  if (error) {
    printf ("ERROR: %s\n", error->message);
    g_clear_error (&error);
    return 1;
  }

  remmem_client = g_object_new (TYPE_REMOTE_MEMORY_TEST_CLIENT,
                                "input_protocol",  remmem_protocol,
                                "output_protocol", remmem_protocol,
                                NULL);
  
  arrcomp_socket    = g_object_new (THRIFT_TYPE_SOCKET,
                            "hostname",  "0:0:103::",
                            "port",      9280,
                            NULL);
  arrcomp_transport = g_object_new (THRIFT_TYPE_BUFFERED_TRANSPORT,
                            "transport", arrcomp_socket,
                            NULL);
  arrcomp_protocol  = g_object_new (THRIFT_TYPE_BINARY_PROTOCOL,
                            "transport", arrcomp_transport,
                            NULL);

  thrift_transport_open (arrcomp_transport, &error);
  if (error) {
    printf ("ERROR: %s\n", error->message);
    g_clear_error (&error);
    return 1;
  }

  arrcomp_client = g_object_new (TYPE_SIMPLE_ARRAY_COMPUTATION_CLIENT,
                                 "input_protocol",  arrcomp_protocol,
                                 "output_protocol", arrcomp_protocol,
                                 NULL);

  printf("\n\n###### Server functionality tests ######\n");
  test_server_functionality(remmem_client);

  printf("\n####### Shared pointer RPC tests #######\n");
  test_shared_pointer_rpc(arrcomp_client);

  printf("\n####### Shared pointer performance tests #######\n");
  test_shared_pointer_perf(remmem_client, arrcomp_client, iterations);

  printf("\n\nCleaning up...\n");
  thrift_transport_close (remmem_transport, NULL);
  thrift_transport_close (arrcomp_transport, NULL);

  g_object_unref (remmem_client);
  g_object_unref (remmem_protocol);
  g_object_unref (remmem_transport);
  g_object_unref (remmem_socket);

  g_object_unref (arrcomp_client);
  g_object_unref (arrcomp_protocol);
  g_object_unref (arrcomp_transport);
  g_object_unref (arrcomp_socket);

  return 0;
}
